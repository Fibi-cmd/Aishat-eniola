<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Divine Mystery — 3D Love Quiz (Professor Edition)</title>
<meta name="description" content="A long-form 3D love quiz game — multi-level, mini-games, timed questions, lifelines, and progressive scoring."/>
<style>
/* =========================================================================
   Divine Mystery — 3D Love Quiz
   Professor / Engineer notes included in code comments.
   Mobile-first responsive layout, accessible controls, visual polish.
   ========================================================================= */

/* Reset + base */
:root{
  --bg:#0b1020;
  --card:#0f1724;
  --accent:#ff6fa3;
  --accent-2:#00d4ff;
  --muted:#98a0b3;
  --glass: rgba(255,255,255,0.03);
  --glass-2: rgba(255,255,255,0.04);
  --success:#34d399;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
  background: radial-gradient(1200px 600px at 10% 10%, rgba(255,111,167,0.07), transparent),
              radial-gradient(1000px 500px at 90% 90%, rgba(0,212,255,0.03), transparent),
              var(--bg);
  color: #e6eef8;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  overflow:hidden;
}

/* Particle canvas fills background */
#bg-canvas{
  position:fixed; inset:0; width:100%; height:100%; z-index:0; pointer-events:none;
}

/* App shell */
.app {
  position:relative;
  z-index:2;
  min-height:100vh;
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:20px;
  gap:18px;
}

/* Header / Title */
.header {
  width:100%;
  max-width:1100px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.title {
  display:flex;
  gap:12px;
  align-items:center;
}
.logo {
  width:56px; height:56px; border-radius:12px;
  background: linear-gradient(135deg,var(--accent),var(--accent-2));
  box-shadow:0 6px 30px rgba(0,0,0,0.6), 0 2px 10px rgba(255,111,163,0.08) inset;
  display:flex; align-items:center; justify-content:center; font-weight:700;
  font-family: "Great Vibes", cursive; font-size:26px; color:#081021;
}
.h1 {
  font-size:1.25rem; font-weight:700;
  letter-spacing:0.6px;
}
.sub { font-size:0.85rem; color:var(--muted) }

/* Main board area */
.board {
  width:100%;
  max-width:1100px;
  display:grid;
  grid-template-columns: 320px 1fr;
  gap:18px;
  align-items:start;
}

/* Left panel — player info, progress, lifelines */
.left {
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:14px;
  padding:14px;
  border: 1px solid rgba(255,255,255,0.03);
  box-shadow: 0 8px 40px rgba(0,0,0,0.6);
  min-height:420px;
  height:fit-content;
}
.profile {
  display:flex; gap:12px; align-items:center;
}
.avatar {
  width:72px; height:72px; border-radius:12px;
  background:linear-gradient(135deg,var(--accent),var(--accent-2));
  display:flex; align-items:center; justify-content:center; font-weight:800; color:#081021;
  font-size:20px;
}
.info {flex:1}
.info h3 {margin:0; font-size:1rem}
.info p {margin:4px 0 0; color:var(--muted); font-size:0.85rem}

/* progress ring placeholder */
.progress-wrap { margin-top:12px; display:flex; gap:10px; align-items:center; }
.ring { width:72px; height:72px; border-radius:50%; background:conic-gradient(var(--accent) var(--progress,40%), rgba(255,255,255,0.04) 0); display:flex; align-items:center; justify-content:center; font-weight:700}
.scorebox { flex:1; color:var(--muted) }
.stat { font-size:0.9rem; color:#dff; font-weight:700 }

/* lifelines */
.lifelines { margin-top:14px }
.lifline-list { display:flex; gap:10px; flex-wrap:wrap }
.lifeline {
  background:var(--glass);
  padding:8px 10px; border-radius:10px; font-size:13px; cursor:pointer; color:var(--muted);
  border:1px solid rgba(255,255,255,0.03);
  display:flex; gap:8px; align-items:center;
}
.lifeline.disabled { opacity:0.35; pointer-events:none }

/* Level list */
.levels { margin-top:16px; display:flex; gap:8px; flex-direction:column }
.level {
  background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
  padding:10px; border-radius:8px; display:flex; justify-content:space-between; align-items:center;
  border:1px solid rgba(255,255,255,0.02);
}
.level small { color:var(--muted) }

/* Right panel — stage area */
.right {
  background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
  padding:18px;
  border-radius:14px;
  min-height:420px;
  border:1px solid rgba(255,255,255,0.03);
  box-shadow: 0 12px 50px rgba(0,0,0,0.6);
  position:relative;
  overflow:hidden;
}

/* 3D card area */
.stage {
  display:flex; flex-direction:column; gap:14px;
}
.card-3d {
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  padding:18px;
  border-radius:12px;
  transform-style:preserve-3d;
  perspective:900px;
  border:1px solid rgba(255,255,255,0.03);
}
.card-inner {
  transition: transform 600ms cubic-bezier(.17,.67,.14,1.02);
  transform-style: preserve-3d;
  transform-origin:center;
  will-change:transform;
  display:block;
}

/* front face */
.front {
  backface-visibility:hidden;
  transform:translateZ(0);
}
.card-title { font-size:1.05rem; margin-bottom:6px; font-weight:700 }
.card-desc { color:var(--muted); margin-bottom:12px }

/* question area */
.question {
  font-size:1.12rem; margin-bottom:10px;
  line-height:1.4;
}
.answers { display:flex; flex-direction:column; gap:10px }
.answer {
  background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
  padding:12px 14px; border-radius:10px;
  border:1px solid rgba(255,255,255,0.02);
  cursor:pointer; font-weight:600; color:#eaf6ff;
  transition: transform .12s ease, box-shadow .12s ease, background .12s;
}
.answer:hover { transform:translateY(-3px); box-shadow:0 10px 30px rgba(0,0,0,0.6) }
.answer.correct { background: linear-gradient(90deg, rgba(52,211,153,0.12), rgba(52,211,153,0.06)); border-color:rgba(52,211,153,0.25) }
.answer.wrong { background: linear-gradient(90deg, rgba(255,111,163,0.06), rgba(255,111,163,0.03)); border-color: rgba(255,111,163,0.25) }

/* footer controls */
.controls { display:flex; gap:8px; margin-top:12px; align-items:center; flex-wrap:wrap }
.btn {
  padding:10px 12px; background:linear-gradient(90deg,var(--accent),var(--accent-2));
  color:#081021; border:none; border-radius:10px; cursor:pointer; font-weight:700;
  box-shadow: 0 8px 20px rgba(0,0,0,0.45);
}
.btn.secondary { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.03) }

/* timer/progress bar */
.timer {
  display:flex; align-items:center; gap:12px; margin-top:10px;
}
.timebar {
  height:10px; background: rgba(255,255,255,0.04); border-radius:20px; width:100%;
  overflow:hidden; border:1px solid rgba(255,255,255,0.02)
}
.timefill {
  height:100%; width:0%; background: linear-gradient(90deg,var(--accent),var(--accent-2));
  transition: width 0.25s linear;
}

/* mini-game overlay */
.overlay {
  position:absolute; inset:0; z-index:5; display:none; align-items:center; justify-content:center;
  background: linear-gradient(180deg, rgba(2,6,23,0.72), rgba(2,6,23,0.65));
}
.overlay.active { display:flex }
.minigame {
  width:95%; max-width:820px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:12px; padding:18px; border:1px solid rgba(255,255,255,0.03)
}

/* hearts and collectibles style for mini-game */
.hearts-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(56px,1fr)); gap:12px }
.heart {
  height:64px; border-radius:10px; display:flex; align-items:center; justify-content:center;
  font-size:28px; cursor:pointer; user-select:none; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.025);
  transition: transform .18s ease, opacity .18s;
}
.heart.collected { transform:scale(.8) rotate(-10deg); opacity:.22; pointer-events:none }

/* memory match */
.memory-grid { display:grid; grid-template-columns: repeat(4, 1fr); gap:10px }
.card-mem { background:rgba(255,255,255,0.02); height:70px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:22px; cursor:pointer }
.card-mem.flipped { background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#081021 }

/* small screens */
@media (max-width:880px){
  .board { grid-template-columns: 1fr; }
  .left { order:2; width:100% }
  .right { order:1; width:100% }
  .header{ flex-direction:column; align-items:flex-start; gap:8px }
  .logo { width:48px; height:48px; font-size:20px }
}

/* tiny phones */
@media (max-width:420px){
  .avatar{ width:56px; height:56px; font-size:16px }
  .ring{ width:60px; height:60px; font-size:13px }
  .certificate-btn{ padding:8px 10px }
}
</style>
</head>
<body>
<canvas id="bg-canvas"></canvas>

<div class="app" role="application" aria-label="Divine Mystery Love Quiz">
  <div class="header" role="banner">
    <div class="title">
      <div class="logo" aria-hidden="true">💞</div>
      <div>
        <div class="h1">Divine Mystery — Love Quiz</div>
        <div class="sub">Professor-mode: Patient. Engineer-mode: Precise.</div>
      </div>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <div class="sub">Estimated play: 30–60 minutes</div>
      <button class="btn secondary" id="resetBtn" title="Reset progress">Reset</button>
    </div>
  </div>

  <div class="board" role="main">
    <!-- LEFT -->
    <aside class="left" aria-label="Player info and controls">
      <div class="profile">
        <div class="avatar" id="avatar">A</div>
        <div class="info">
          <h3 id="playerName">My Love</h3>
          <p id="playerSub">Ready to discover the Divine Mystery?</p>
        </div>
      </div>

      <div class="progress-wrap" aria-hidden="true">
        <div class="ring" id="progRing">0%</div>
        <div class="scorebox">
          <div class="stat" id="score">Score: 0</div>
          <small class="sub" id="levelInfo">Level 1 • Question 1/5</small>
        </div>
      </div>

      <div class="lifelines">
        <h4 style="margin:10px 0 8px">Lifelines</h4>
        <div class="lifline-list" id="lifelines">
          <div class="lifeline" data-key="hint"><span>💡</span> Hint (3)</div>
          <div class="lifeline" data-key="skip"><span>⏭️</span> Skip (2)</div>
          <div class="lifeline" data-key="time"><span>⏱️</span> +15s (2)</div>
        </div>
      </div>

      <div class="levels">
        <h4 style="margin:10px 0 6px">Levels</h4>
        <!-- populated by JS -->
        <div id="levelList"></div>
      </div>
    </aside>

    <!-- RIGHT -->
    <section class="right" aria-live="polite">
      <div class="stage">
        <div class="card-3d" id="card">
          <div class="card-inner" id="cardInner" aria-hidden="false">
            <div class="front">
              <div class="card-title" id="cardTitle">Welcome, Scholar of Love</div>
              <div class="card-desc">Professor instructions: Read carefully. Use lifelines sparingly.</div>

              <!-- question block -->
              <div class="question" id="questionArea">Press <strong>Start</strong> to begin the Divine Mystery. There are several levels; each level has 5 questions and one mini-game intermission. Good luck.</div>

              <div class="answers" id="answersArea" aria-label="Answer choices"></div>

              <div class="timer" role="timer" aria-live="assertive">
                <div style="min-width:80px;font-weight:700" id="timerText">00:00</div>
                <div class="timebar"><div class="timefill" id="timeFill"></div></div>
              </div>

              <div class="controls">
                <button class="btn" id="startBtn">Start</button>
                <button class="btn secondary" id="nextBtn" style="display:none">Next</button>
                <button class="btn secondary" id="openMiniBtn" style="display:none">Play Mini-game</button>
                <div style="margin-left:auto; display:flex; gap:8px">
                  <div style="font-size:0.9rem; color:var(--muted)">Hints left: <span id="hintsLeft">3</span></div>
                </div>
              </div>
            </div>
          </div>
        </div>

      </div>

      <!-- mini-game overlay -->
      <div class="overlay" id="overlay" aria-hidden="true">
        <div class="minigame" id="minigameBox">
          <!-- content injected -->
        </div>
      </div>

    </section>
  </div>
</div>

<script>
/*
  Divine Mystery — JS Engine
  Professor notes:
   - Structured for clarity: model (state), view-updates, controllers (event handlers).
   - Lifelines consume counts. Progress saved in localStorage under 'divine_mystery_save'.
   - Timers are per question. Mini-games run between levels.
   - You can expand questions array to add more content.
*/

/* -------------------------
   Utilities
   ------------------------- */
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
function el(tag, attrs={}, ...kids){
  const e = document.createElement(tag);
  for(let k in attrs){
    if(k.startsWith('on')) e.addEventListener(k.slice(2), attrs[k]);
    else if(k==='html') e.innerHTML = attrs[k];
    else e.setAttribute(k, attrs[k]);
  }
  kids.forEach(k=>{ if(typeof k==='string') e.appendChild(document.createTextNode(k)); else if(k) e.appendChild(k); });
  return e;
}

/* -------------------------
   Game data (questions)
   - Each level has 5 questions (configurable)
   - Questions include: text, choices (4), answerIndex (0-3), hint.
   ------------------------- */
const levelsData = [
  {
    id:1, name:"Foundations of Affection",
    description:"Warm-up questions about love, memory, and small gestures.",
    questions:[
      {q:"Which small daily habit often matters most in a relationship?", choices:["Lavish gifts","Consistent listening","Ignoring messages","Only grand gestures"], a:1, hint:"It's about paying attention rather than price."},
      {q:"A simple 'I care' text is an example of what?", choices:["Transactional favor","Emotional maintenance","Strategic move","Irrelevant action"], a:1, hint:"Short, frequent reminders keep connection alive."},
      {q:"What's more valuable for trust?", choices:["Secrecy","Reliability","Dramatic apologies","Charisma"], a:1, hint:"Consistency beats drama."},
      {q:"Which is a 'love language' commonly recognized?", choices:["Quality time","Sales pitch","Competitive dieting","Silent treatment"], a:0, hint:"Spending focused time together."},
      {q:"What often helps during argument?", choices:["Winning","Shutting down","Active listening","Ignoring"], a:2, hint:"Try to understand before replying."}
    ]
  },
  {
    id:2, name:"Romantic Chemistry",
    description:"Questions about attraction, compatibility, and shared goals.",
    questions:[
      {q:"What signals emotional availability?", choices:["Closed body language","Avoiding conversation","Open vulnerability","Interrupting"], a:2, hint:"Sharing feelings gently."},
      {q:"A healthy boundary is:", choices:["Always saying yes","Listening without consent","Expressing limits kindly","Punishing partner"], a:2, hint:"Respectful limits are healthy."},
      {q:"Compatibility is best measured by:", choices:["Identical hobbies","Shared values","Matching bank accounts","Same friends"], a:1, hint:"Long-term alignment matters."},
      {q:"Romantic surprise is effective when:", choices:["It matches partner's likes","It benefits you","It's expensive","It's public"], a:0, hint:"Consider what they enjoy."},
      {q:"Laughter in a relationship often indicates:", choices:["Boredom","Resentment","Emotional bonding","Apathy"], a:2, hint:"Shared humor builds rapport."}
    ]
  },
  {
    id:3, name:"Deep Hearts",
    description:"Deeper questions about commitment and future planning.",
    questions:[
      {q:"Trust grows primarily through:", choices:["One big gesture","Repeated small acts","Financial dependency","Avoidance"], a:1, hint:"Small acts compound over time."},
      {q:"Long term conflict handling should be:", choices:["Avoided","Escalated","Collaborative","Ignored"], a:2, hint:"Solve problems together."},
      {q:"Shared rituals (e.g., weekly date) are:", choices:["Restrictive","Bonding","Pointless","Dramatic"], a:1, hint:"They create predictability and care."},
      {q:"Saying 'I'm wrong' demonstrates:", choices:["Weakness","Accountability","Indifference","Control"], a:1, hint:"Accountability encourages repair."},
      {q:"Healthy independence means:", choices:["No contact","Mutual growth","Isolation","One-sided dependence"], a:1, hint:"Supporting each other's growth."}
    ]
  },
  {
    id:4, name:"Playful Sparks",
    description:"Fun, playful questions to keep romance light-hearted.",
    questions:[
      {q:"A playful text should be:", choices:["Mean","Teasing and kind","Confusing","Cold"], a:1, hint:"Tease with care and warmth."},
      {q:"Gifts that show thought are:", choices:["Generic","Personalized","Expensive only","Seen by others"], a:1, hint:"Small personal details matter."},
      {q:"Cute nicknames often:", choices:["Embarrass","Annoy","Create intimacy","Distance people"], a:2, hint:"Endearments increase closeness."},
      {q:"Inside jokes in a couple:", choices:["Exclude everyone","Hurt feelings","Bond partners","Are rude"], a:2, hint:"Shared language builds identity."},
      {q:"Romantic playlist is:", choices:["Useless","Thoughtful","Tacky","Irrelevant"], a:1, hint:"Music can trigger memories."}
    ]
  }
];

/* Mini-games: we will provide two mini-games alternating:
   - Heart Collector (click hearts) — simple, calming
   - Memory Match (pairing)
   Each mini-game returns a "bonusScore" (0..n)
*/

/* -------------------------
   Game state model
   ------------------------- */
const model = {
  playerName: localStorage.getItem('dm_name') || 'My Love',
  levelIndex: Number(localStorage.getItem('dm_level')) || 0,   // 0-based for levelsData
  questionIndex: Number(localStorage.getItem('dm_q')) || 0,
  score: Number(localStorage.getItem('dm_score')) || 0,
  lifelines: {
    hint: Number(localStorage.getItem('dm_hint')) || 3,
    skip: Number(localStorage.getItem('dm_skip')) || 2,
    time: Number(localStorage.getItem('dm_time')) || 2
  },
  playing: false,
  perQuestionTime: 45, // seconds
  timer: null,
  timeLeft: 0,
  answered: false
};

/* -------------------------
   DOM refs
   ------------------------- */
const startBtn = $('#startBtn');
const nextBtn = $('#nextBtn');
const openMiniBtn = $('#openMiniBtn');
const questionArea = $('#questionArea');
const answersArea = $('#answersArea');
const timerText = $('#timerText');
const timeFill = $('#timeFill');
const progRing = $('#progRing');
const scoreNode = $('#score');
const levelInfoNode = $('#levelInfo');
const lifelineNodes = document.getElementById('lifelines');
const hintsLeftNode = $('#hintsLeft');
const overlay = $('#overlay');
const minigameBox = $('#minigameBox');
const levelListNode = $('#levelList');
const resetBtn = $('#resetBtn');

/* -------------------------
   Initialize UI / bindings
   ------------------------- */
function initUI(){
  // set player name display
  $('#playerName').textContent = model.playerName;
  $('#avatar').textContent = (model.playerName[0] || 'A').toUpperCase();

  // lifelines rendering is static; we update counts
  updateLifelinesUI();

  // build level list
  levelListNode.innerHTML = '';
  levelsData.forEach((lvl, idx)=> {
    const div = el('div',{class:'level', onclick:()=> jumpToLevel(idx)}, 
      el('div',{}, el('strong',{}, lvl.name)),
      el('small',{}, `Level ${idx+1}`)
    );
    levelListNode.appendChild(div);
  });

  // progress UI
  updateProgressUI();

  // button events
  startBtn.onclick = startGame;
  nextBtn.onclick = nextQuestion;
  openMiniBtn.onclick = () => startMiniGame();
  resetBtn.onclick = resetProgress;

  // lifeline events
  lifelineNodes.querySelectorAll('.lifeline').forEach(node => {
    node.addEventListener('click', () => useLifeline(node.dataset.key));
  });

  // load saved state into UI (if any)
  renderQuestion();
}

/* -------------------------
   Persistence
   ------------------------- */
function saveState(){
  localStorage.setItem('dm_level', model.levelIndex);
  localStorage.setItem('dm_q', model.questionIndex);
  localStorage.setItem('dm_score', model.score);
  localStorage.setItem('dm_hint', model.lifelines.hint);
  localStorage.setItem('dm_skip', model.lifelines.skip);
  localStorage.setItem('dm_time', model.lifelines.time);
  localStorage.setItem('dm_name', model.playerName);
}

/* -------------------------
   Update UI functions
   ------------------------- */
function updateLifelinesUI(){
  $('#hintsLeft').textContent = model.lifelines.hint;
  lifelineNodes.querySelectorAll('.lifeline').forEach(node=>{
    const key = node.dataset.key;
    if(model.lifelines[key] <= 0) node.classList.add('disabled'); else node.classList.remove('disabled');
    node.querySelector('span') && (node.querySelector('span').textContent = key==='hint'?'💡': key==='skip'?'⏭️':'⏱️');
    node.childNodes.length > 1 && (node.childNodes[1].textContent = ` ${key.charAt(0).toUpperCase()+key.slice(1)} (${model.lifelines[key]})`);
  })
}

function updateProgressUI(){
  // percentage of levels completed + question progress
  const totalQuestions = levelsData.reduce((s,l)=> s + l.questions.length, 0);
  const levelProgress = (model.levelIndex * 1.0 * 100 / levelsData.length);
  const currentLevel = levelsData[model.levelIndex] || levelsData[0];
  const questionTotal = currentLevel.questions.length;
  const questionNumber = model.questionIndex + 1;
  const overallPct = Math.floor((model.levelIndex*questionTotal + model.questionIndex) / (levelsData.length*questionTotal) * 100);
  progRing.style.setProperty('--progress', `${overallPct}%`);
  progRing.textContent = `${overallPct}%`;
  scoreNode.textContent = `Score: ${model.score}`;
  levelInfoNode.textContent = `Level ${model.levelIndex+1} • Question ${model.questionIndex+1}/${questionTotal}`;
}

/* -------------------------
   Game logic: question rendering & handling
   ------------------------- */
function renderQuestion(){
  // If playing false, show welcome text
  if(!model.playing){
    questionArea.innerHTML = `Press <strong>Start</strong> to begin the Divine Mystery. There are ${levelsData.length} levels. Each level: ${levelsData[0].questions.length} questions and one mini-game.`;
    answersArea.innerHTML = '';
    $('#startBtn').style.display = 'inline-block';
    $('#nextBtn').style.display = 'none';
    $('#openMiniBtn').style.display = 'none';
    timerText.textContent = formatTime(model.perQuestionTime);
    timeFill.style.width = '0%';
    return;
  }

  // ensure indexes are in bounds
  if(model.levelIndex >= levelsData.length){
    finishGame();
    return;
  }

  const lvl = levelsData[model.levelIndex];
  const qset = lvl.questions;
  if(model.questionIndex >= qset.length){
    // level finished -> enable mini-game button
    questionArea.innerHTML = `<strong>Level ${model.levelIndex+1} complete!</strong><br/>Play the mini-game to earn bonus points and unlock next level.`;
    answersArea.innerHTML = '';
    $('#startBtn').style.display = 'none';
    $('#nextBtn').style.display = 'none';
    $('#openMiniBtn').style.display = 'inline-block';
    $('#openMiniBtn').textContent = 'Play Mini-game';
    updateProgressUI();
    return;
  }

  const q = qset[model.questionIndex];
  $('#cardTitle').textContent = `${lvl.name} — Question ${model.questionIndex+1}`;
  questionArea.textContent = q.q;
  answersArea.innerHTML = '';
  q.choices.forEach((c, idx) => {
    const node = el('div', {class:'answer', tabindex:0}, c);
    node.addEventListener('click', ()=> selectAnswer(idx));
    node.addEventListener('keydown', ev => { if(ev.key==='Enter') selectAnswer(idx) });
    answersArea.appendChild(node);
  });

  // reset timers / flags
  model.answered = false;
  startTimer(model.perQuestionTime);
  $('#startBtn').style.display = 'none';
  $('#nextBtn').style.display = 'none';
  $('#openMiniBtn').style.display = 'none';
  updateProgressUI();
}

/* -------------------------
   Timer
   ------------------------- */
function startTimer(seconds){
  clearTimer();
  model.timeLeft = seconds;
  timeFill.style.width = '100%';
  updateTimerText();
  const total = seconds;
  model.timer = setInterval(() => {
    model.timeLeft--;
    if(model.timeLeft < 0){
      clearTimer();
      onTimeUp();
    } else {
      updateTimerText();
      timeFill.style.width = `${(model.timeLeft/total)*100}%`;
    }
  }, 1000);
}
function clearTimer(){ if(model.timer) { clearInterval(model.timer); model.timer = null; } }
function updateTimerText(){ timerText.textContent = formatTime(model.timeLeft); }
function formatTime(sec){
  const s = Math.max(0, Math.floor(sec));
  const m = Math.floor(s/60);
  const r = s%60;
  return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
}
function onTimeUp(){
  // auto mark wrong and move on after small delay
  if(model.answered) return;
  const answers = Array.from(answersArea.children);
  answers.forEach(a=> a.classList.add('wrong'));
  model.answered = true;
  // small penalty
  model.score = Math.max(0, model.score - 2);
  saveState(); updateProgressUI();
  setTimeout(()=> {
    // show correct and allow next
    revealCorrect();
    $('#nextBtn').style.display = 'inline-block';
  }, 1000);
}

/* -------------------------
   Answer selection logic
   ------------------------- */
function selectAnswer(idx){
  if(model.answered) return;
  model.answered = true;
  clearTimer();

  const lvl = levelsData[model.levelIndex];
  const q = lvl.questions[model.questionIndex];
  const answers = Array.from(answersArea.children);
  answers.forEach((a, i) => {
    if(i===q.a){
      a.classList.add('correct');
    }
    if(i===idx && i!==q.a){
      a.classList.add('wrong');
    }
    a.style.pointerEvents = 'none';
  });

  if(idx===q.a){
    // correct
    model.score += 10;
    scoreNode.textContent = `Score: ${model.score}`;
    // small visual flourish
    flashAccent();
  } else {
    // wrong
    model.score = Math.max(0, model.score - 3);
  }
  saveState();
  updateProgressUI();

  // show next button after a beat
  setTimeout(()=> {
    $('#nextBtn').style.display = 'inline-block';
  }, 900);
}

function revealCorrect(){
  const lvl = levelsData[model.levelIndex];
  const q = lvl.questions[model.questionIndex];
  Array.from(answersArea.children).forEach((a, i)=>{
    if(i===q.a) a.classList.add('correct');
  });
}

/* -------------------------
   Controls: start, next, jump, finish
   ------------------------- */
function startGame(){
  model.playing = true;
  // reset if at end
  if(model.levelIndex >= levelsData.length) { model.levelIndex = 0; model.questionIndex = 0; model.score = 0; }
  saveState();
  renderQuestion();
}
function nextQuestion(){
  // move to next question or end of level
  const lvl = levelsData[model.levelIndex];
  const qLen = lvl.questions.length;
  if(model.questionIndex < qLen - 1){
    model.questionIndex++;
  } else {
    // level complete
    // show mini-game button
    model.questionIndex = qLen; // sentinel for level-complete
  }
  model.answered = false;
  saveState();
  renderQuestion();
}
function jumpToLevel(idx){
  model.levelIndex = idx;
  model.questionIndex = 0;
  saveState();
  renderQuestion();
}

/* -------------------------
   Lifelines: hint, skip, time
   ------------------------- */
function useLifeline(key){
  if(model.lifelines[key] <= 0) return;
  if(!model.playing) return;
  // consume
  model.lifelines[key]--;
  if(key==='hint'){
    // show hint for current question
    const lvl = levelsData[model.levelIndex];
    const q = lvl.questions[model.questionIndex];
    if(q && q.hint){
      // show toast (simple)
      showToast("Hint: " + q.hint);
    } else showToast("No hint available.");
  } else if(key==='skip'){
    showToast("Question skipped. No points awarded.");
    // jump to next question
    nextQuestion();
  } else if(key==='time'){
    // add time
    model.timeLeft = Math.min(model.perQuestionTime, model.timeLeft + 15);
    updateTimerText();
    showToast("+15s added");
  }
  updateLifelinesUI();
  saveState();
}

/* -------------------------
   Mini-games
   ------------------------- */
let lastMiniWas = null;

function startMiniGame(){
  overlay.classList.add('active');
  overlay.setAttribute('aria-hidden','false');
  // alternate between two mini-games
  if(lastMiniWas === 'hearts' || lastMiniWas===null){
    lastMiniWas = 'memory';
    startMemoryMini();
  } else {
    lastMiniWas = 'hearts';
    startHeartsMini();
  }
}

/* Hearts collector mini-game */
function startHeartsMini(){
  minigameBox.innerHTML = '';
  const header = el('div',{}, el('h3',{}, 'Heart Collector — find & click hearts'), el('p',{}, 'Collect hearts as quickly as you can. Each collected heart gives bonus points.'));
  const grid = el('div',{class:'hearts-grid', style:'margin-top:12px'});
  // generate 12 hearts; some are decoys
  const total = 12;
  let collected = 0;
  for(let i=0;i<total;i++){
    const heart = el('div',{class:'heart', tabindex:0}, '💖');
    // randomly make some decoys (bomb) with lower points (less likely)
    const isSpecial = Math.random() < 0.18;
    heart.addEventListener('click', ()=> {
      if(heart.classList.contains('collected')) return;
      heart.classList.add('collected');
      collected++;
      // compute immediate visual
      heart.textContent = isSpecial ? '💎' : '💖';
      // award
      const points = isSpecial ? 8 : 3;
      model.score += points;
      showToast(`Collected +${points}`);
      updateProgressUI(); saveState();
      if(collected >= Math.floor(total*0.6)){
        // after enough collected, end mini
        setTimeout(()=> endMiniGame(collected*2), 600);
      }
    });
    grid.appendChild(heart);
  }
  const btn = el('button',{class:'btn', onclick:()=> endMiniGame( Math.floor(Math.random()*6) ) }, 'Give Up');
  minigameBox.appendChild(header);
  minigameBox.appendChild(grid);
  minigameBox.appendChild(el('div',{style:'margin-top:12px;display:flex;gap:8px;align-items:center'}, btn, el('div',{}, el('small',{}, 'Collect hearts to boost score.'))));
}

/* Memory match mini-game */
function startMemoryMini(){
  minigameBox.innerHTML = '';
  const header = el('div',{}, el('h3',{}, 'Memory Match — find matching pairs'), el('p',{}, 'Flip cards and find pairs. Reward for pairs found quickly.'));
  const icons = ['🌹','🌟','💫','🍫','🎵','💌','🎁','🔥']; // 8 pairs
  let deck = icons.concat(icons).sort(()=>Math.random()-0.5);
  const grid = el('div',{class:'memory-grid', style:'margin-top:12px'});
  let first=null, second=null, lock=false, pairs=0;
  deck.forEach((icon, idx)=>{
    const c = el('div',{class:'card-mem', tabindex:0}, '');
    c.dataset.icon = icon;
    c.addEventListener('click', ()=> {
      if(lock || c.classList.contains('flipped')) return;
      c.classList.add('flipped');
      c.textContent = icon;
      if(!first) { first = c; return; }
      second = c; lock = true;
      setTimeout(()=> {
        if(first.dataset.icon === second.dataset.icon){
          pairs++; model.score += 6;
          first.style.pointerEvents='none'; second.style.pointerEvents='none';
          showToast('+6 bonus');
        } else {
          first.classList.remove('flipped'); first.textContent='';
          second.classList.remove('flipped'); second.textContent='';
        }
        first = second = null; lock=false; updateProgressUI(); saveState();
        if(pairs >= icons.length){
          endMiniGame(icons.length*4 + Math.floor(Math.random()*6));
        }
      }, 700);
    });
    grid.appendChild(c);
  });
  const btn = el('button',{class:'btn', onclick:()=> endMiniGame( Math.floor(Math.random()*6) ) }, 'Give Up');
  minigameBox.appendChild(header);
  minigameBox.appendChild(grid);
  minigameBox.appendChild(el('div',{style:'margin-top:12px;display:flex;gap:8px;align-items:center'}, btn));
}

/* End mini-game and resume to next level */
function endMiniGame(bonusScore){
  // bonusScore is awarded additionally
  const bonus = Math.max(0, Number(bonusScore));
  model.score += bonus;
  showToast(`Mini-game complete! Bonus +${bonus}`);
  // hide overlay
  overlay.classList.remove('active');
  overlay.setAttribute('aria-hidden','true');
  // advance to next level
  model.levelIndex = Math.min(levelsData.length - 1, model.levelIndex + 1);
  model.questionIndex = 0;
  model.answered = false;
  saveState();
  renderQuestion();
}

/* -------------------------
   Finish game
   ------------------------- */
function finishGame(){
  clearTimer();
  $('#cardTitle').textContent = 'Divine Mystery — Complete';
  questionArea.innerHTML = `Congratulations. You've completed all levels. Final score: <strong>${model.score}</strong>.`;
  answersArea.innerHTML = '';
  $('#startBtn').style.display = 'inline-block'; $('#startBtn').textContent = 'Play Again';
  $('#nextBtn').style.display = 'none'; $('#openMiniBtn').style.display = 'none';
  showToast('You finished the Divine Mystery. Well done!');
  saveState();
}

/* -------------------------
   Helpers: toast & visual effects
   ------------------------- */
let toastTimer = null;
function showToast(msg){
  // simple ephemeral message near top-right
  let toast = document.getElementById('dm_toast');
  if(!toast){
    toast = el('div',{id:'dm_toast', style:'position:fixed;top:22px;right:22px;background:linear-gradient(90deg,var(--accent),var(--accent-2));padding:10px 14px;border-radius:10px;color:#081021;z-index:9999;box-shadow:0 8px 30px rgba(0,0,0,0.6);font-weight:700'});
    document.body.appendChild(toast);
  }
  toast.textContent = msg;
  toast.style.opacity = '1';
  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(()=> toast.style.opacity='0', 2400);
}
function flashAccent(){
  const el = document.querySelector('.logo');
  el.animate([{transform:'scale(1)'},{transform:'scale(1.08)'},{transform:'scale(1)'}], {duration:500, easing:'ease'});
}

/* -------------------------
   Reset
   ------------------------- */
function resetProgress(){
  if(!confirm('Reset Divine Mystery progress? This will clear your score and lifelines.')) return;
  localStorage.removeItem('dm_level');
  localStorage.removeItem('dm_q');
  localStorage.removeItem('dm_score');
  localStorage.removeItem('dm_hint');
  localStorage.removeItem('dm_skip');
  localStorage.removeItem('dm_time');
  localStorage.removeItem('dm_name');
  // reset model
  model.levelIndex = 0; model.questionIndex = 0; model.score = 0;
  model.lifelines = { hint:3, skip:2, time:2 };
  model.playing = false;
  saveState(); updateLifelinesUI(); updateProgressUI(); renderQuestion();
}

/* -------------------------
   Particle background (canvas)
   Lightweight JS particle system — professor's mini-engine.
   ------------------------- */
(function initParticles(){
  const canvas = document.getElementById('bg-canvas');
  const ctx = canvas.getContext('2d');
  let w=canvas.width=innerWidth, h=canvas.height=innerHeight;
  window.addEventListener('resize', ()=>{ w=canvas.width=innerWidth; h=canvas.height=innerHeight; });

  const num = Math.floor((w*h)/42000);
  const particles = [];
  for(let i=0;i<num;i++) particles.push({ x:Math.random()*w, y:Math.random()*h, r: Math.random()*1.6+0.6, vx:(Math.random()-0.5)*0.2, vy:(Math.random()-0.5)*0.2, hue: Math.random()*360 });

  function draw(){
    ctx.clearRect(0,0,w,h);
    particles.forEach(p=>{
      p.x += p.vx; p.y += p.vy;
      if(p.x<0) p.x = w; if(p.x>w) p.x=0;
      if(p.y<0) p.y = h; if(p.y>h) p.y=0;
      const g = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*10);
      g.addColorStop(0, 'rgba(255,111,163,0.08)');
      g.addColorStop(0.6, 'rgba(0,212,255,0.03)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.beginPath();
      ctx.fillStyle = g;
      ctx.arc(p.x,p.y,p.r*6,0,Math.PI*2);
      ctx.fill();
    });
    requestAnimationFrame(draw);
  }
  draw();
})();

/* -------------------------
   Accessibility small enhancements
   ------------------------- */
document.addEventListener('keydown', (e)=>{
  if(e.key===' ' && document.activeElement.tagName !== 'INPUT') { // spacebar acts as start/next
    e.preventDefault();
    if($('#startBtn').style.display !== 'none') startGame();
    else if($('#nextBtn').style.display !== 'none') nextQuestion();
  }
});

/* -------------------------
   Boot
   ------------------------- */
initUI();
renderQuestion();

/* Expose for debugging */
window.DM = { model, levelsData, renderQuestion, startGame, nextQuestion, useLifeline, resetProgress };

</script>
</body>
</html>
